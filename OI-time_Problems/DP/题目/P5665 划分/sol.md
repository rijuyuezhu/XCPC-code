头一次才知道单调队列可以这样写！

#### 36pts

这个分就是个暴力dp

`dp[i][j]`表示在`[1,i]`的区间中，在最后一段前的那个位置是`j`（即最后一段是`[j+1,i]`）的所耗时间。

那么可以枚举区间`[?,j]`的前驱进行转移

#### 64pts

方法1：

考虑优化上面的dp。我们发现条件`sum[i]-sum[j]>=sum[j]-sum[k]`在`j`固定的时候，k是随着i单调变化的。

所以可以采用2-pointers方法，顺便维护`min{dp[j][t]},t is in [k, j-1]`，可以用单调队列维护

方法2：(未写)

我们发现，分段分得越多越好，最后一段越短越好。

那么，我们只要求出，对于每一个i，最大的满足条件的j，然后再从j转移就好了

O(n^2)

#### 88 / 100pts

（这两个差的就是个高精把）

由方法2我们知道，只要求对于每一个i，满足条件的最大的j就行了，不妨把这个最大的j记作g[i]

那么，我们要求的是

`g[i] = max{j}, st.sum[i] >= 2sum[j] - sum[g[j]]`

那么`sum[i]`是递增的。

我们只要求一个j，使得 

对any j' > j , st. sum[i] < 2sum[j'] - sum[g[j']]，且sum[i]>=2sum[j]-sum[g[j]]$

故这是一个有单调性的东西，具体就像代码里一样维护