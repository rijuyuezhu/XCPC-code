<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>36pts</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 18px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <p>头一次才知道单调队列可以这样写！</p>
<h4 id="36pts">36pts</h4>
<p>这个分就是个暴力dp</p>
<p><code>dp[i][j]</code>表示在<code>[1,i]</code>的区间中，在最后一段前的那个位置是<code>j</code>（即最后一段是<code>[j+1,i]</code>）的所耗时间。</p>
<p>那么可以枚举区间<code>[?,j]</code>的前驱进行转移</p>
<h4 id="64pts">64pts</h4>
<p>方法1：</p>
<p>考虑优化上面的dp。我们发现条件<code>sum[i]-sum[j]&gt;=sum[j]-sum[k]</code>在<code>j</code>固定的时候，k是随着i单调变化的。</p>
<p>所以可以采用2-pointers方法，顺便维护<code>min{dp[j][t]},t is in [k, j-1]</code>，可以用单调队列维护</p>
<p>方法2：(未写)</p>
<p>我们发现，分段分得越多越好，最后一段越短越好。</p>
<p>那么，我们只要求出，对于每一个i，最大的满足条件的j，然后再从j转移就好了</p>
<p>O(n^2)</p>
<h4 id="88--100pts">88 / 100pts</h4>
<p>（这两个差的就是个高精把）</p>
<p>由方法2我们知道，只要求对于每一个i，满足条件的最大的j就行了，不妨把这个最大的j记作g[i]</p>
<p>那么，我们要求的是</p>
<p><code>g[i] = max{j}, st.sum[i] &gt;= 2sum[j] - sum[g[j]]</code></p>
<p>那么<code>sum[i]</code>是递增的。</p>
<p>我们只要求一个j，使得</p>
<p>对any j' &gt; j , st. sum[i] &lt; 2sum[j'] - sum[g[j']]，且sum[i]&gt;=2sum[j]-sum[g[j]]$</p>
<p>故这是一个有单调性的东西，具体就像代码里一样维护</p>

    </body>
    </html>