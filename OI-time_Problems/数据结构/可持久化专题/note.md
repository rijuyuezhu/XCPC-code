# 可持久化数据结构专题

[toc]

## 何为可持久化

我就不找定义了，按照我的理解来说。我们知道，一个DS（即数据结构）能干的事，归根结底都是——维护。维护一个什么东西的改变，维护一个性质...可持久化DS与普通DS的差异在于它的数据的**改变**。一般的数据结构，比如旋转Treap，它的操作必须具有**时间连续性**。在一次插入/删除后，你能且只能询问插入/删除后的Treap中的数据，而不可能访问2次修改前、3次修改前的数据。而可持久化DS通过某些方法（这些方法我们等下说），使得我们可以访问多次修改前的数据，甚至在它们的基础上产生另外的、不同的修改。

画图形象的理解，普通DS的修改、询问就像一个链，只能一个接一个地完成；而可持久化DS却像一棵树，从一个节点可以有多个分支。

## 实现可持久化的基本方法：path copying

即复制路径。这个东西推荐去**Reference**里找文章读，看完主席树的讲解，你应当能够理解什么叫做**copying**。

## 具体可持久化的数据结构

### 可持久化线段树

线段树可以维护许多信息：序列信息和权值信息。如果我们将维护序列信息的线段树进行可持久化，会得到可以维护**一个序列的历史版本**的可持久化线段树。如果我们将维护权值信息的线段树进行可持久化，会得到可以维护**一个集合历史版本**的可持久化线段树。另外，在可持久化的权值线段树中，有一种用得相当广泛、特别好用的东西，叫做主席树，我们等下在说。

我们先看可持久化序列线段树。

### 例题1： 可持久化数组

[可持久化数组](https://www.luogu.com.cn/problem/P3919)

这就是可持久化线段树的模板题了。

~~当然你可以用其他的玩意，比如可持久化平衡树。~~

关键代码:

```cpp
void update(int &o, int pre, int l, int r, int x, int val) {
		o = ++tot; e[o] = e[pre];
		if(l == r) {e[o].val = val; return ;}
		int m = (l + r) >> 1; 
		if(x <= m) update(L, e[pre].ls, l, m, x, val);
		else update(R, e[pre].rs, m+1, r, x, val);
}
```

在pre的基础上path-copying出一份来。

### 例题2：可持久化并查集

[可持久化并查集](https://www.luogu.com.cn/problem/P3402)

其实和上一题差不多，用可持久化线段树来维护 $fa$ 数组。

值得注意的是，由于这个玩意不能路径压缩（路径压缩太多修改了，TLE+MLE），采取按秩合并的方法。这道题很多题解都是错的：[某讨论](https://www.luogu.com.cn/discuss/show/93295)。望周知。

### 例题3：主席树

[主席树](https://www.luogu.com.cn/problem/P3834)

什么是主席树？不同的人有不同的理解。我的理解是一种特殊的可持久化权值线段树。它采用一种差分的思想来快速处理区间问题。

我们知道，用数据结构维护**时间前缀**是相当好维护的（对大部分问题来说），计算每个操作的贡献。而**时间区间**却有时并不好维护。好维护的时候可以转化为两个时间前缀做差（当答案的贡献相当独立时），有时会变得相当棘手。这时可以有（至少）两种思路，一是加一维，用更高的时空复杂度来维护，比如树套树、cdq分治、整体二分等；另一种就是主席树。

主席树的应用相当广泛，题目也很多。在这里给出关键的例题代码，即主席树上的二分

```cpp
int query(int u, int v, int l, int r, int k) {
	if(l == r) return l;
	int m = (l + r) >> 1;
	if(k <= e[e[v].ls].num - e[e[u].ls].num) return query(e[u].ls, e[v].ls, l, m, k);
	else return query(e[u].rs, e[v].rs, m+1, r, k - (e[e[v].ls].num - e[e[u].ls].num));
}
```

(未完待续)



## Reference

[数据结构——主席树&可持久化数组 - 菜鸡mk - 博客园 (cnblogs.com)](https://www.cnblogs.com/jrdxy/p/12558119.html)

