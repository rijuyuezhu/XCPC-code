<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>&#x70B9;&#x5206;&#x6CBB; &#x5B66;&#x4E60;&#x7B14;&#x8BB0;</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 18px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="点分治-学习笔记">点分治 学习笔记</h1>
<p>2021/2/18: 终于重拾点分治。</p>
<h2 id="点分治概述">点分治概述</h2>
<p>点分治采用层层分治的方法，以点为分治中心，能较好地完成无根树上的链（或者说点对）的统计任务。但由于点分治的特性（它重构了树），它无法相当有效地完成与有根树的祖孙结构（比如子树）有关的统计任务。</p>
<h2 id="树的重心">树的重心</h2>
<h3 id="定义">定义</h3>
<p>有两个相互等价的定义：</p>
<p><strong>定义1：</strong> 若树上存在一点，使得该点删去后形成若干个连通块，每个连通块的点数都 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mrow><mo fence="true">⌊</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo fence="true">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">\le \left \lfloor \dfrac n 2\right \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.8359999999999999em;vertical-align:-0.686em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord">2</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault">n</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">⌋</span></span></span></span></span></span> ，则该点称为树的重心。</p>
<p><strong>定义2：</strong>  删去树上一点，使得形成的若干连通块中最大的那个的大小最小化的点称为树的重心。</p>
<h3 id="性质">性质</h3>
<p>奇数点数的树有且仅有一个重心，偶数点数的树有 一个重心 或 相邻的两个重心。</p>
<h2 id="点分治重构树点分树">点分治重构树（点分树）</h2>
<h3 id="定义-1">定义</h3>
<p><img src="file:///d:\OneDrive - UOTAGO\资料\OI\收集\题目\图论与树\点分治\D:%5COneDrive%20-%20UOTAGO%5C%E7%AC%94%E8%AE%B0%5C%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C20210219090330309.png" alt="picture"></p>
<p>如图，2（红点） 是整个树的重心，称作第一级重心；4,6,7（蓝点）是删去第一级重心形成的三个连通块分别的重心，称作第二级重心；同理，黑点是第三级重心。</p>
<p>我们把树的 <strong>各级重心</strong> 找到，重新连边，就形成了点分治重构树（点分树）。</p>
<h3 id="性质-1">性质</h3>
<p>我们把点分树上两点记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，它们在点分树上的 lca 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>。</p>
<p>则：</p>
<ol>
<li>原树中的路径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 一定经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>。</li>
<li>点分树的树高为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</li>
</ol>
<h2 id="点分治">点分治</h2>
<p>点分治的最基本思想为：枚举点分树上的每个点，统计其子树的信息。</p>
<p>一般来说，点分治有两种实现方式，下面以一道例题呈现。</p>
<p><a href="https://www.luogu.com.cn/problem/P4178">P4178 Tree</a></p>
<blockquote>
<p>给定一棵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个节点的树，每条边有边权，求出树上两点距离小于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的点对数量。</p>
</blockquote>
<h3 id="实现方式1">实现方式1</h3>
<p><img src="file:///d:\OneDrive - UOTAGO\资料\OI\收集\题目\图论与树\点分治\D:%5COneDrive%20-%20UOTAGO%5C%E7%AC%94%E8%AE%B0%5C%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C20210219090330309.png" alt="picture"></p>
<p>我们在重构树上 dfs，对每个节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 统计 <strong>经过</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的路径数量。</p>
<p>我们暂且不考虑以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 为端点的路径，只考虑 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 这样的路径（其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">a</mi></mrow><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\mathrm{lca}(y,z)=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">l</span><span class="mord mathrm">c</span><span class="mord mathrm">a</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>）。形式化地，若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的所有子树为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>y</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">y_1,y_2,\cdots,y_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，我们依次考虑 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y_i(1\le i\le k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 子树和之前的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>y</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">y_1,y_2,\cdots,y_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 棵子树之间形成的路径，用数据维护统计，统计完后再把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的信息并入。那么如何统计以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 为端点的路径呢？大部分时候可以直接以一种数据结构初始化的形式（比如一开始插入一个值等）得到。</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-keyword">char</span> In[<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>], *ss = In, *tt = In;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> getchar() (ss == tt &amp;&amp; (tt = (ss = In) + fread(In, 1, 1 &lt;&lt; 20, stdin), ss == tt) ? EOF : *ss++)</span>
<span class="hljs-function">ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{
	ll x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> ch = getchar();
	<span class="hljs-keyword">for</span>(; ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>; ch = getchar()) <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">for</span>(; ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; ch = getchar()) x = x * <span class="hljs-number">10</span> + <span class="hljs-keyword">int</span>(ch - <span class="hljs-string">&#x27;0&#x27;</span>);
	<span class="hljs-keyword">return</span> x * f;
}
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">4e4</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;
<span class="hljs-keyword">int</span> n, head[MAXN], ver[MAXN &lt;&lt; <span class="hljs-number">1</span>], nxt[MAXN &lt;&lt; <span class="hljs-number">1</span>], cnt, edg[MAXN &lt;&lt; <span class="hljs-number">1</span>], k, sz[MAXN], mxsz[MAXN], tsz, rt, vis[MAXN], ans, tree, d[MAXN], dnum;
<span class="hljs-keyword">namespace</span> Treap {
    <span class="hljs-comment">//平衡树</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span><span class="hljs-keyword">int</span> ls, rs, v, s, c, k;}e[MAXN];
	<span class="hljs-keyword">int</span> tot;
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>{e[p].s = e[e[p].ls].s + e[e[p].rs].s + e[p].c;}
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lturn</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; p)</span> </span>{<span class="hljs-keyword">int</span> s = e[p].rs; e[p].rs = e[s].ls; upd(p); e[s].ls = p; upd(s); p = s;}
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rturn</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; p)</span> </span>{<span class="hljs-keyword">int</span> s = e[p].ls; e[p].ls = e[s].rs; upd(p); e[s].rs = p; upd(s); p = s;}
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ins</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; p, <span class="hljs-keyword">int</span> v)</span> </span>{
		<span class="hljs-keyword">if</span>(!p) e[p = ++tot] = (Node){<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, v, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, rand()};
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e[p].v == v) e[p].c++, upd(p);
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e[p].v &gt; v)
			ins(e[p].ls, v), e[p].k &gt; e[e[p].ls].k ? rturn(p) : upd(p);
		<span class="hljs-keyword">else</span>
			ins(e[p].rs, v), e[p].k &gt; e[e[p].rs].k ? lturn(p) : upd(p);
	}
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">le</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> v)</span> </span>{
		<span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e[p].v == v) <span class="hljs-keyword">return</span> e[e[p].ls].s + e[p].c;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e[p].v &gt; v) <span class="hljs-keyword">return</span> le(e[p].ls, v);
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> e[e[p].ls].s + e[p].c + le(e[p].rs, v);
	}
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>{
	ver[++cnt] = v; nxt[cnt] = head[u]; edg[cnt] = w; head[u] = cnt;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> f)</span> </span>{
    <span class="hljs-comment">//求重心</span>
	sz[u] = <span class="hljs-number">1</span>; mxsz[u] = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i; i = nxt[i]) {
		<span class="hljs-keyword">int</span> v = ver[i]; <span class="hljs-keyword">if</span>(v == f || vis[v]) <span class="hljs-keyword">continue</span>;
		getrt(v, u); sz[u] += sz[v]; mxsz[u] = max(mxsz[u], sz[v]);
	}
	mxsz[u] = max(mxsz[u], tsz - sz[u]);
	<span class="hljs-keyword">if</span>(mxsz[u] &lt; mxsz[rt]) rt = u;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getdis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> f, <span class="hljs-keyword">int</span> w)</span> </span>{
    <span class="hljs-comment">//得到一个子树内的距离信息</span>
	d[++dnum] = w;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i; i = nxt[i]) {
		<span class="hljs-keyword">int</span> v = ver[i]; <span class="hljs-keyword">if</span>(v == f || vis[v]) <span class="hljs-keyword">continue</span>;
		getdis(v, u, w + edg[i]);
	}
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>{
	tree = Treap::tot = <span class="hljs-number">0</span>;
	Treap::ins(tree, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i; i = nxt[i]) {
		<span class="hljs-keyword">int</span> v = ver[i]; <span class="hljs-keyword">if</span>(vis[v]) <span class="hljs-keyword">continue</span>;
		dnum = <span class="hljs-number">0</span>;
		getdis(v, u, edg[i]);
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= dnum; i++) ans += Treap::le(tree, k - d[i]);<span class="hljs-comment">//统计信息</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= dnum; i++) Treap::ins(tree, d[i]);<span class="hljs-comment">//合并信息</span>
	}
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>{
	vis[u] = <span class="hljs-number">1</span>; calc(u);
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i; i = nxt[i]) {
		<span class="hljs-keyword">int</span> v = ver[i]; <span class="hljs-keyword">if</span>(vis[v]) <span class="hljs-keyword">continue</span>;
		tsz = sz[v]; mxsz[rt = <span class="hljs-number">0</span>] = INF;
        <span class="hljs-comment">/*
        水平较高的同学可能发现这个 tsz 可能是错误的，那么不妨看看这篇博客：
        https://liu-cheng-ao.blog.uoj.ac/blog/2969
        */</span>
		getrt(v, u); solve(rt);
	}
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
	n = read();
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
		<span class="hljs-keyword">int</span> u = read(), v = read(), w = read();
		addedge(u, v, w); addedge(v, u, w);
	}
	k = read();
	tsz = n; mxsz[rt = <span class="hljs-number">0</span>] = INF;
	getrt(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); solve(rt);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="实现方式2">实现方式2</h3>
<p>我们在重构树上 dfs，对每个节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 统计 <strong>经过</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的路径数量。</p>
<p>考虑怎么统计。我们采用一种容斥的思路。我们用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>a</mi><mi>l</mi><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">calc(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 表示统计 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的子树的信息。这里的统计是点对统计，即</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>a</mi><mi>l</mi><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>∈</mo><mi>s</mi><mi>u</mi><mi>b</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></munder><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mtext>符合条件</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">calc(x)=\sum_{u,v\in subtree(x)}[(u,v)符合条件]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">e</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">条</span><span class="mord cjk_fallback">件</span><span class="mclose">]</span></span></span></span></span></p>
<p>问题是这样可能会导致 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 的 lca 不为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>（当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的同一子树中），于是根据容斥原理，我们要把这样的信息减掉。</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-keyword">char</span> In[<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>], *ss = In, *tt = In;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> getchar() (ss == tt &amp;&amp; (tt = (ss = In) + fread(In, 1, 1 &lt;&lt; 20, stdin), ss == tt) ? EOF : *ss++)</span>
<span class="hljs-function">ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{
	ll x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> ch = getchar();
	<span class="hljs-keyword">for</span>(; ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>; ch = getchar()) <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">for</span>(; ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; ch = getchar()) x = x * <span class="hljs-number">10</span> + <span class="hljs-keyword">int</span>(ch - <span class="hljs-string">&#x27;0&#x27;</span>);
	<span class="hljs-keyword">return</span> x * f;
}
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">4e4</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;
<span class="hljs-keyword">int</span> n, head[MAXN], ver[MAXN &lt;&lt; <span class="hljs-number">1</span>], nxt[MAXN &lt;&lt; <span class="hljs-number">1</span>], cnt, edg[MAXN &lt;&lt; <span class="hljs-number">1</span>], k, sz[MAXN], mxsz[MAXN], tsz, rt, vis[MAXN], d[MAXN], dnum, ans;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>{
	ver[++cnt] = v; nxt[cnt] = head[u]; edg[cnt] = w; head[u] = cnt;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> f)</span> </span>{
	sz[u] = <span class="hljs-number">1</span>; mxsz[u] = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i; i = nxt[i]) {
		<span class="hljs-keyword">int</span> v = ver[i]; <span class="hljs-keyword">if</span>(v == f || vis[v]) <span class="hljs-keyword">continue</span>;
		getrt(v, u); sz[u] += sz[v]; mxsz[u] = max(mxsz[u], sz[v]);
	}
	mxsz[u] = max(mxsz[u], tsz - sz[u]);
	<span class="hljs-keyword">if</span>(mxsz[u] &lt; mxsz[rt]) rt = u;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getdis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> f, <span class="hljs-keyword">int</span> dis)</span> </span>{
	d[++dnum] = dis;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i; i = nxt[i]) {
		<span class="hljs-keyword">int</span> v = ver[i]; <span class="hljs-keyword">if</span>(v == f || vis[v]) <span class="hljs-keyword">continue</span>;
		getdis(v, u, dis + edg[i]);
	}
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> dis)</span> </span>{
    <span class="hljs-comment">//统计 u 的子树的信息，注意这里的 dis ，是为了保证容斥时（减去子树的信息时）得到的子树信息与原来统计时一致。</span>
	<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>; dnum = <span class="hljs-number">0</span>;
	getdis(u, <span class="hljs-number">0</span>, dis);
	sort(d + <span class="hljs-number">1</span>, d + <span class="hljs-number">1</span> + dnum);
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = dnum; i &lt;= n &amp;&amp; i &lt;= j; i++) {
		<span class="hljs-keyword">while</span>(d[i] + d[j] &gt; k) j--;
		<span class="hljs-keyword">if</span>(i &lt;= j) ans += j - i;
	}
	<span class="hljs-keyword">return</span> ans;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>{
	vis[u] = <span class="hljs-number">1</span>; ans += calc(u, <span class="hljs-number">0</span>);<span class="hljs-comment">//加上 u 的信息。</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i; i = nxt[i]) {
		<span class="hljs-keyword">int</span> v = ver[i]; <span class="hljs-keyword">if</span>(vis[v]) <span class="hljs-keyword">continue</span>;
		ans -= calc(v, edg[i]);<span class="hljs-comment">//容斥，减去 u 的每棵子树内部的信息。</span>
		tsz = sz[v]; mxsz[rt = <span class="hljs-number">0</span>] = INF;
		getrt(v, u); solve(rt);
	}
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
	n = read();
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
		<span class="hljs-keyword">int</span> u = read(), v = read(), w = read();
		addedge(u, v, w); addedge(v, u, w);
	}
	k = read();
	tsz = n; mxsz[rt = <span class="hljs-number">0</span>] = INF;
	getrt(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); solve(rt);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="对比">对比</h3>
<p>第一种实现方式普适性很强，不仅可以维护可减的信息，还可以维护最值等不可减信息。</p>
<p>第二种实现方式较为巧妙，代码相对好写，但只能维护可以容斥（可减）的信息。</p>
<p>如果有多组询问，不妨建立点分树，这样的话，可以减小常数。如果将各个点的信息进行存储（见下），则可以将单次询问的复杂度优化（去掉一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>）。</p>
<h2 id="动态点分治">动态点分治</h2>
<p>如果树信息加上修改，怎么办呢？可以建立点分树，用数据结构维护每个点的信息。由于点分树最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span> 层，若在每个节点存点分树上子树内的节点信息，空间是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的。这样，在查询/修改一个点的信息时，其实只要在点分树上跳父亲即可。一般来说，基于容斥（第二种实现方式）的比较好做。第一种实现方式为保证复杂度，需要限制每个点的度数（添加虚点，多叉树转二叉树）。</p>
<p><a href="https://www.luogu.com.cn/problem/P6329">P6329 【模板】点分树 | 震波</a></p>

    </body>
    </html>